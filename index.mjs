import{forwardRef as t}from"react";const e=(t,e)=>[t,e].filter(Boolean).join(" "),r=(...t)=>t.reduce(((t,o)=>{if(o){const n=(t=>{if("string"==typeof t||"number"==typeof t)return`${t}`;if(Array.isArray(t))return r(...t);if("object"==typeof t){let o="";for(let n in t)t[n]&&(o=e(o,r(n)));return o}return""})(o);return e(t,n)}return t}),""),o=t=>{if("object"!=typeof t||null===t)return!1;const e=Object.getPrototypeOf(t);return!(null!==e&&e!==Object.prototype&&null!==Object.getPrototypeOf(e)||Symbol.toStringTag in t||Symbol.iterator in t)},n=(...t)=>t.length?t.reduce(((t,e)=>{if("object"!=typeof e||Array.isArray(e))return t;for(const r in e)o(e[r])&&!Array.isArray(e[r])?t[r]=n(t[r],e[r]):"function"==typeof e[r]?t[r]=e[r]:t[r]=structuredClone(e[r]);return t}),{}):{},s=t=>t;function a(t,e){const{className:o,component:a,ref:c,props:l,extraProps:i,classNameMergeFn:f=s}=e,{component:u,slots:p={[t]:void 0},slotProps:m={[t]:void 0},...y}=l,b={[t]:void 0,...m},d="root"===t&&u?u:p[t]??a,g=f(r(o??"",{[l.className]:"root"===t&&!!l.className},i?.className??!1,b[t]?.className));return[d,Object.assign(n("root"===t?y:{},i,b[t],g?{className:g}:{}),{ref:c})]}function c(e,r){const o=t(e);return o.displayName=r??`@zemd/react-slottable/${e.name??"UnknownComponent"}`,o}export{r as clsx,c as createSlottableComponent,n as mergeProps,c as slottable,a as useSlot};
